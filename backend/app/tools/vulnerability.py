"""
Vulnerability Assessment Tools
==============================

Integration for vulnerability scanning and web application testing:
- Nuclei: Fast vulnerability scanner
- OWASP ZAP: Web application security scanner
"""

import json
import re
from typing import List, Dict, Any, Optional
from pathlib import Path

from .base import BaseSecurityTool, ToolError


class NucleiTool(BaseSecurityTool):
    """Nuclei integration for fast vulnerability scanning"""
    
    @property
    def tool_name(self) -> str:
        return "nuclei"
    
    def get_default_path(self) -> str:
        return "nuclei"  # Assume in PATH
    
    def build_command(self, 
                     target: str, 
                     options: Dict[str, Any] = None) -> List[str]:
        """Build nuclei command"""
        options = options or {}
        target = self.sanitize_target(target)
        
        command = [self.tool_path]
        
        # Target specification
        if options.get('target_list'):
            # Multiple targets from file
            command.extend(['-l', options['target_list']])
        else:
            # Single target
            command.extend(['-u', target])
        
        # Template selection
        templates = options.get('templates')
        if templates:
            if isinstance(templates, list):
                for template in templates:
                    command.extend(['-t', template])
            else:
                command.extend(['-t', templates])
        else:
            # Use default templates
            command.extend(['-t', 'cves/'])
        
        # Severity filtering
        severity = options.get('severity')
        if severity:
            command.extend(['-severity', severity])
        
        # Tags filtering
        tags = options.get('tags')
        if tags:
            command.extend(['-tags', tags])
        
        # Exclude tags
        exclude_tags = options.get('exclude_tags')
        if exclude_tags:
            command.extend(['-exclude-tags', exclude_tags])
        
        # Output formats
        output_base = self.get_output_filename(target, '')
        
        # JSON output (primary)
        json_file = str(self.output_dir / f"{output_base}.json")
        command.extend(['-json', '-o', json_file])
        
        # Additional output formats
        if options.get('markdown_output'):
            md_file = str(self.output_dir / f"{output_base}.md")
            command.extend(['-markdown-export', md_file])
        
        # Performance tuning
        concurrency = options.get('concurrency', '25')
        command.extend(['-c', str(concurrency)])
        
        rate_limit = options.get('rate_limit', '150')
        command.extend(['-rl', str(rate_limit)])
        
        timeout = options.get('timeout', '5')
        command.extend(['-timeout', str(timeout)])
        
        # HTTP options
        if options.get('user_agent'):
            command.extend(['-H', f"User-Agent: {options['user_agent']}"])
        
        if options.get('headers'):
            for header in options['headers']:
                command.extend(['-H', header])
        
        # Proxy settings
        if options.get('proxy'):
            command.extend(['-proxy', options['proxy']])
        
        # Follow redirects
        if options.get('follow_redirects', True):
            command.append('-fr')
        
        # Silent mode
        if options.get('silent', True):
            command.append('-silent')
        
        # No interaction
        command.append('-ni')
        
        return command
    
    def parse_output(self, 
                    stdout: str, 
                    stderr: str, 
                    output_files: List[str] = None) -> List[Dict[str, Any]]:
        """Parse nuclei JSON output"""
        findings = []
        
        # Try to parse JSON output file first
        json_files = [f for f in (output_files or []) if f.endswith('.json')]
        if json_files:
            findings.extend(self._parse_json_output(json_files[0]))
        
        # Fallback to stdout parsing
        if not findings and stdout.strip():
            findings.extend(self._parse_text_output(stdout))
        
        return findings
    
    def _parse_json_output(self, json_file: str) -> List[Dict[str, Any]]:
        """Parse nuclei JSON output"""
        findings = []
        
        try:
            with open(json_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    
                    try:
                        result = json.loads(line)
                        finding = self._convert_nuclei_result(result)
                        if finding:
                            findings.append(finding)
                    except json.JSONDecodeError:
                        continue
        
        except Exception as e:
            self.logger.warning(f"Failed to parse nuclei JSON: {e}")
        
        return findings
    
    def _convert_nuclei_result(self, result: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Convert nuclei result to standard finding format"""
        info = result.get('info', {})
        
        # Extract severity
        severity_map = {
            'info': 'info',
            'low': 'low', 
            'medium': 'medium',
            'high': 'high',
            'critical': 'critical'
        }
        
        severity = info.get('severity', 'info').lower()
        mapped_severity = severity_map.get(severity, 'info')
        
        finding = {
            'type': 'vulnerability',
            'title': info.get('name', 'Unknown vulnerability'),
            'description': info.get('description', ''),
            'severity': mapped_severity,
            'category': 'web_vulnerability',
            'tool': 'nuclei',
            
            # Target information
            'target': result.get('host', ''),
            'matched_at': result.get('matched-at', ''),
            
            # Template information
            'template_id': result.get('template-id', ''),
            'template_path': result.get('template-path', ''),
            
            # Technical details
            'tags': info.get('tags', []),
            'reference': info.get('reference', []),
            'author': info.get('author', []),
            'metadata': info.get('metadata', {}),
            
            # HTTP details
            'method': result.get('method', ''),
            'curl_command': result.get('curl-command', ''),
            
            # Raw response
            'raw_response': result
        }
        
        # Add CVE information if available
        classification = info.get('classification', {})
        if 'cve-id' in classification:
            finding['cve_id'] = classification['cve-id']
        
        if 'cvss-score' in classification:
            finding['cvss_score'] = float(classification['cvss-score'])
        
        if 'cvss-vector' in classification:
            finding['cvss_vector'] = classification['cvss-vector']
        
        # Add CWE information
        if 'cwe-id' in classification:
            finding['cwe_id'] = classification['cwe-id']
        
        # Extract matcher information
        matcher_name = result.get('matcher-name', '')
        if matcher_name:
            finding['matcher'] = matcher_name
        
        # Extract extracted data
        extracted_results = result.get('extracted-results', [])
        if extracted_results:
            finding['extracted_data'] = extracted_results
        
        return finding
    
    def _parse_text_output(self, stdout: str) -> List[Dict[str, Any]]:
        """Parse nuclei text output as fallback"""
        findings = []
        
        # Basic pattern matching for text output
        # Format: [template-id] [target] [vulnerability-name]
        pattern = r'\[([^\]]+)\]\s+\[([^\]]+)\]\s+(.+)'
        
        for line in stdout.split('\n'):
            line = line.strip()
            if not line:
                continue
            
            match = re.match(pattern, line)
            if match:
                template_id, target, vuln_name = match.groups()
                
                finding = {
                    'type': 'vulnerability',
                    'title': vuln_name,
                    'severity': 'medium',  # Default
                    'category': 'web_vulnerability',
                    'tool': 'nuclei',
                    'target': target,
                    'template_id': template_id
                }
                
                findings.append(finding)
        
        return findings


class ZapTool(BaseSecurityTool):
    """OWASP ZAP integration for web application security testing"""
    
    @property
    def tool_name(self) -> str:
        return "zap-baseline"
    
    def get_default_path(self) -> str:
        return "zap-baseline.py"  # ZAP baseline script
    
    def build_command(self, 
                     target: str, 
                     options: Dict[str, Any] = None) -> List[str]:
        """Build ZAP baseline command"""
        options = options or {}
        target = self.sanitize_target(target)
        
        command = [
            'python3',  # ZAP baseline script is Python
            self.tool_path,
            '-t', target
        ]
        
        # Report formats
        output_base = self.get_output_filename(target, '')
        
        # JSON report (primary)
        json_file = str(self.output_dir / f"{output_base}.json")
        command.extend(['-J', json_file])
        
        # HTML report
        if options.get('html_report', True):
            html_file = str(self.output_dir / f"{output_base}.html")
            command.extend(['-r', html_file])
        
        # XML report
        if options.get('xml_report'):
            xml_file = str(self.output_dir / f"{output_base}.xml")
            command.extend(['-x', xml_file])
        
        # Additional options
        if options.get('ajax_spider', True):
            command.append('-j')  # Use Ajax spider
        
        if options.get('passive_scan_only'):
            command.append('-P')  # Passive scan only
        
        # Authentication
        if options.get('auth_script'):
            command.extend(['-z', options['auth_script']])
        
        # Context file
        if options.get('context_file'):
            command.extend(['-n', options['context_file']])
        
        # Timeout
        timeout = options.get('scan_timeout', '5')
        command.extend(['-T', str(timeout)])
        
        # Exclude URLs
        if options.get('exclude_urls'):
            for exclude_url in options['exclude_urls']:
                command.extend(['-x', exclude_url])
        
        # User agent
        if options.get('user_agent'):
            command.extend(['-z', f"-config spider.userAgent={options['user_agent']}"])
        
        # Additional ZAP options
        if options.get('zap_options'):
            command.extend(['-z', options['zap_options']])
        
        return command
    
    def parse_output(self, 
                    stdout: str, 
                    stderr: str, 
                    output_files: List[str] = None) -> List[Dict[str, Any]]:
        """Parse ZAP output"""
        findings = []
        
        # Try to parse JSON output
        json_files = [f for f in (output_files or []) if f.endswith('.json')]
        if json_files:
            findings.extend(self._parse_zap_json(json_files[0]))
        
        return findings
    
    def _parse_zap_json(self, json_file: str) -> List[Dict[str, Any]]:
        """Parse ZAP JSON report"""
        findings = []
        
        try:
            with open(json_file, 'r') as f:
                data = json.load(f)
            
            # ZAP JSON structure
            site = data.get('site', [])
            if isinstance(site, list) and site:
                site = site[0]  # Take first site
            
            alerts = site.get('alerts', [])
            
            for alert in alerts:
                finding = self._convert_zap_alert(alert)
                if finding:
                    findings.append(finding)
        
        except Exception as e:
            self.logger.warning(f"Failed to parse ZAP JSON: {e}")
        
        return findings
    
    def _convert_zap_alert(self, alert: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Convert ZAP alert to standard finding format"""
        # Map ZAP risk levels to severity
        risk_map = {
            'High': 'high',
            'Medium': 'medium', 
            'Low': 'low',
            'Informational': 'info'
        }
        
        risk = alert.get('riskdesc', 'Low')
        # Extract just the risk level (before any parentheses)
        risk_level = risk.split('(')[0].strip()
        severity = risk_map.get(risk_level, 'low')
        
        finding = {
            'type': 'vulnerability',
            'title': alert.get('name', 'Unknown vulnerability'),
            'description': alert.get('desc', ''),
            'severity': severity,
            'category': 'web_vulnerability',
            'tool': 'zap',
            
            # ZAP specific fields
            'plugin_id': alert.get('pluginid'),
            'alert_ref': alert.get('alertRef'),
            'solution': alert.get('solution', ''),
            'reference': alert.get('reference', ''),
            'other_info': alert.get('otherinfo', ''),
            
            # CWE/WASC classification
            'cwe_id': alert.get('cweid'),
            'wasc_id': alert.get('wascid'),
            
            # Confidence
            'confidence': alert.get('confidence', '').lower(),
            
            # Instances
            'instances': []
        }
        
        # Process instances (specific vulnerable URLs/parameters)
        instances = alert.get('instances', [])
        for instance in instances:
            instance_info = {
                'uri': instance.get('uri'),
                'method': instance.get('method'),
                'param': instance.get('param'),
                'attack': instance.get('attack'),
                'evidence': instance.get('evidence')
            }
            finding['instances'].append(instance_info)
            
            # Use first instance as primary target
            if not finding.get('target'):
                finding['target'] = instance.get('uri', '')
        
        return finding
    
    def _is_partial_success(self, exit_code: int, stdout: str, stderr: str) -> bool:
        """ZAP can complete successfully with warnings"""
        # ZAP baseline script can return non-zero but still produce results
        return exit_code in [0, 1, 2] and "WARN" in stderr